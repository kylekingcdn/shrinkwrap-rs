use serde::Serialize;
use shrinkwrap::{ToWrappedWith, Transform, TransformToNest, Wrap};

// -- data definition

// Create a single nest with an ID of text (also implicitly assigns struct names and the field name for the nest)
#[derive(Debug, Clone, Serialize, Wrap)]
#[shrinkwrap(transform = MyTransform)]
#[shrinkwrap(nest(id = "text", field_type = String))]
pub struct MyData {
    // include this field in the text nest
    #[shrinkwrap(nests("text"))]
    uptime_sec: i64,
}

// -- transform

// If unused, a transform opt struct definition can be substituted with an empty tuple type alias.
//    - e.g. `type Options = ()`
//
// Transform options are used to control aspects of transformation in realtime, without mutating the transform's state/
// A common use-case for this is dynamically including/excluding an optional nest:
//
// ```
// struct MyTransformOpts {
//     with_text: bool, // example of an option you would use in the real-world.
// }
// ```
struct MyTransformOpts {}
struct MyTransform {}
impl Transform for MyTransform {
    type Options = MyTransformOpts;
}

// Define how to map from MyData into the text nest (`MyDataNestedText`, automatically generated by the `Wrap` derivation).
//
// Required to implement for each nest.
// Simply maps the data to the desired type, free to use any dependencies provided by your own `MyTransform` struct
impl TransformToNest<MyDataNestedText> for MyTransform {
    type Data = MyData;

    fn transform_to_nest(&self, data: &MyData, _: &MyTransformOpts) -> MyDataNestedText {
        MyDataNestedText {
            uptime_sec: data.uptime_sec.to_string(),
        }
    }
}

// -- integration example

pub fn main() -> Result<(), serde_json::Error> {
    println!("Starting example: minimal");

    // create your (reusable) transform service
    let transform = MyTransform {};
    let transform_opts = MyTransformOpts {};

    // initialize your data
    let data = MyData { uptime_sec: 10 };

    // generate the wrapper with your mapped data nested under 'extra'.
    let wrapped = data.to_wrapped_with(&transform, &transform_opts);

    // - the wrapper can also be generating by any of (blanket implementations handle these automatically)
    //   just don't forget to bring the extra traits into scope as well.
    //
    // use shrinkwrap::WrapDataWith;
    // let wrapped = MyDataWrapper::wrap_data_with(data, &transform, &transform_opts);

    println!("Generated wrapper via transform: {wrapped:#?}");

    Ok(())
}
